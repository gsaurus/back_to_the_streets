//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18063
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;


// Plane model
[Serializable]
public class PhysicPlaneModel: Model<PhysicPlaneModel>, IDeserializationCallback{

	// The first point is considered the plane's origin
	public FixedVector3 origin;

	// List of offsets of the other points to the plane's origin.
	// They must be convex and coplanar
	public SerializableList<FixedVector3> offsets;

	// Position of first point on the previous frame
	public FixedVector3 lastOriginPosition;

	// Normal isn't serialized
	[NonSerialized]
	private FixedVector3 normal;
	public FixedVector3 Normal { get{ return normal; }}



	// Velocity = difference between current and previous positions
	// We use first point as reference
	public FixedVector3 GetVelocity(){
		return origin - lastOriginPosition;
	}

	// Normal computed from the first 2 consecutive offsets
	public void ComputeNormal(){
		// Normal vector
		normal = FixedVector3.Cross(offsets[0], offsets[1]); //(origin + offsets[1]) - (origin + offsets[0]));
		normal.Normalize();
	}


	// As we only store offsets, provide a way of accessing plane points
	public FixedVector3 GetPointFromOffsetId(int offsetId){
		return origin + offsets[offsetId];
	}


	public List<FixedVector3> GetPointsList()
	{
		List<FixedVector3> list = new List<FixedVector3>();
		list.Add(origin);
		for (int i = 0 ; i < offsets.Count ; ++i){
			list.Add(GetPointFromOffsetId(i));
		}
		return list;
	}


	// Constructor giving world points
	public PhysicPlaneModel(int updatingOrder, params FixedVector3[] paramPoints):base(updatingOrder){
		if (paramPoints.Length < 3){
			// Can't build a plane with less than 3 points
			return;
		}
		origin = lastOriginPosition = paramPoints[0];
		offsets = new SerializableList<FixedVector3>(paramPoints.Length-1);
		for(int i = 1 ; i < paramPoints.Length; ++i){
			offsets.Add(paramPoints[i] - origin);
		}
		ComputeNormal();
	}

	// Called once the object is deserialized
	void IDeserializationCallback.OnDeserialization(Object sender)
	{
		// Once deserialized, compute normal
		ComputeNormal();
	}

	// Create controller
	protected override Controller<PhysicPlaneModel> CreateController(){
		return new PhysicPlaneController();
	}


//	protected override View<PhysicPlaneModel> CreateView(){
//		return new DebugPhysicPlaneView(this);
//	}


	// TODO: this should move to PhysicPlaneController!
	// Compute the intersection point against a line segment
	public bool CheckIntersection(FixedVector3 pos1, FixedVector3 pos2, out FixedVector3 intersection){
		// plane may be moving, sum velocity to initial point position
		pos1 += GetVelocity();
	
		// check collision with the hiperplane
		FixedVector3 pointDeltaPos = pos2 - pos1;
		if (pointDeltaPos.Magnitude == 0){
			// The point is not moving relatively to the plane
			intersection = FixedVector3.Zero; return false;
		}
		FixedVector3 pos1ToOrigin = origin - pos1;
		FixedFloat dotDeltaPosNormal = FixedVector3.Dot(pointDeltaPos,normal);
		if (dotDeltaPosNormal >= 0){
			// Point moving away from the plane
			intersection = FixedVector3.Zero;return false;
		}

		// Find intersection location in the deltapos vector
		FixedFloat t = FixedVector3.Dot(pos1ToOrigin, normal) / dotDeltaPosNormal;
	
		// a small delta due to precision errors
		// based on deltaPos magnitude (the smaller the magnitude the higher the error)
		FixedFloat error = 0.01 / pointDeltaPos.Magnitude;
//		if (t > -3 && t < 3){
//			UnityEngine.Debug.Log("Magnitude: " + pointDeltaPos.Magnitude + ", error: " + error);
//		}
		if (t < -error || t > 1 + error) {
			// not colliding
			intersection = FixedVector3.Zero;
			return false;
		}
		intersection = pos1 + t * pointDeltaPos;

		// Check if intersection point is inside the plane
		FixedFloat anglesSum = FixedFloat.Zero;
		FixedVector3 originVector = origin - intersection;
		FixedVector3 vec1 = originVector;
		FixedVector3 vec2 = FixedVector3.Zero;
		FixedVector3 vertex;
		for (int i = 0 ; i < offsets.Count ; ++i){
			vertex = GetPointFromOffsetId(i);
			vec2 = vertex - intersection;
			anglesSum += FixedVector3.Angle(vec1, vec2);
			vec1 = vec2;
		}
		// last vertex with origin
		anglesSum += FixedVector3.Angle(vec2, originVector);
		//UnityEngine.Debug.Log("Check inside --> anglesSum: " + anglesSum);

		// a small delta due to precision errors
		return FixedFloat.Abs(anglesSum - FixedFloat.TwoPI) < 0.05;
	}

}

