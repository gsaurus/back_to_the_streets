// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using RetroBread;
using UnityEngine;


public class WorldObject
{
	public int type;

	public FixedFloat x1;
	public FixedFloat x2;

	// Keep track of visual object
	GameObject view;

	static GameObject rockPrefab;
	static GameObject tree1Prefab;
	static GameObject tree2Prefab;


	static WorldObject(){
		rockPrefab = Resources.Load("rock") as GameObject;
		tree1Prefab = Resources.Load("tree1") as GameObject;
		tree2Prefab = Resources.Load("tree2") as GameObject;
	}

	public WorldObject(int type, FixedFloat x, FixedFloat y) {
		this.type = type;
		this.x1 = x - 0.5f;
		this.x2 = x + 0.5f;

		if (type == 0) {
			view = GameObject.Instantiate(rockPrefab);
		}else if (type % 2 == 0){
			view = GameObject.Instantiate(tree1Prefab);
		}else {
			view = GameObject.Instantiate(tree2Prefab);
		}
		view.transform.eulerAngles = new Vector3(310 + UnityEngine.Random.Range(-2, 2), UnityEngine.Random.Range(-5, 5), UnityEngine.Random.Range(0, 360));
		float radius = UnityEngine.Random.Range(0.75f, 1.25f);
		view.transform.localScale = new Vector3(radius, UnityEngine.Random.Range(0.75f, 1.5f), radius);
		view.transform.localPosition  = new Vector3((float)x, -0.25f, (float)y);
	}


	public void OnDestroy(){
		GameObject.Destroy(view);
	}

}


public class WorldObjects{

	static FixedFloat maxHorizontalDistance = 30;

	static FixedFloat maxDistanceBehind = 10;

	// every 50 units, resort the list
	static FixedFloat controlRange = 50;

	static FixedFloat lastTrackX = 0;

	static List<FixedFloat> yList = new List<FixedFloat>(100);
	static Dictionary<FixedFloat, List<WorldObject>> objectsByY = new Dictionary<FixedFloat, List<WorldObject>>(100);



	public static WorldObject getCollisionObject(FixedFloat x, FixedFloat lastY, FixedFloat newY){
		return null;
	}


	public static void UpdateTrack(FixedFloat minY, FixedFloat maxY) {
		if (yList.Count > 0) {
			// remove old objects
			FixedFloat minKnownY = yList[0];
			if (minY < minKnownY - controlRange) {
				int index;
				for (index = 0 ; index < yList.Count && yList[index] > minY + maxDistanceBehind ; ++index){
					List<WorldObject> objects;
					if (objectsByY.TryGetValue(yList[index], out objects)){
						foreach (WorldObject obj in objects) {
							obj.OnDestroy();
						}
					}
					objectsByY.Remove(yList[index]);
				}
				if (index != yList.Count) {
					yList.RemoveRange(0, index);
				}
			}
		}

		// create more track
		FixedFloat maxKnownY = yList.Count == 0 ? 0 : yList[yList.Count-1];
		while (maxY < maxKnownY + controlRange) {

			FixedFloat nextTrackX = lastTrackX + StateManager.state.Random.NextFloat(-30, 30);
			FixedFloat nextTrackY = maxKnownY - StateManager.state.Random.NextFloat(20, 60);

			FixedFloat nextY;
			for (nextY = maxKnownY - 0.001f ; nextY > nextTrackY ; nextY -= StateManager.state.Random.NextFloat(0.0001f, 2.0f)){
				yList.Add(nextY);
				List<WorldObject> newObjects = new List<WorldObject>();
				FixedFloat centerX;
				FixedFloat randomX;
				do {
					centerX = GetCenterXForY(nextY, maxKnownY, nextTrackY, lastTrackX, nextTrackX);
					randomX = GetRandomXAroundCenter(centerX);
					newObjects.Add(new WorldObject(StateManager.state.Random.NextInt(0, 5), randomX, nextY));
				}while (StateManager.state.Random.NextInt(0, 1) != 0);
				UnityEngine.Debug.Log("next: " + nextY);
				objectsByY.Add(nextY,newObjects);
			}

			lastTrackX = nextTrackX;
			maxKnownY = nextY;

		}
	}



	
	static FixedFloat GetCenterXForY(FixedFloat y, FixedFloat lastY, FixedFloat newY, FixedFloat lastX, FixedFloat newX){
		FixedFloat t = (y-lastY) / (newY - lastY);
		return lastX + t * (newX - lastX);
	}
	
	static FixedFloat GetRandomXAroundCenter(FixedFloat center) {
		FixedFloat randomT = StateManager.state.Random.NextFloat(0, 1);
		randomT = randomT * randomT * randomT;
		randomT = 1 - randomT;
		if (StateManager.state.Random.NextInt(0,1) == 0) {
			randomT *= -1;
		}
		return center + (randomT * maxHorizontalDistance);
	}

}

