// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using RetroBread;
using UnityEngine;


public class WorldObject
{
	public int type;

	public FixedFloat y;
	public FixedFloat x1;
	public FixedFloat x2;
	public bool isRight;

	// Keep track of visual object
	public GameObject view;

	static GameObject[] rocksPool;
	static GameObject[] tree1Pool;
	static GameObject[] tree2Pool;
	static int rockPoolId;
	static int tree1PoolId;
	static int tree2PoolId;

	static GameObject rockPrefab;
	static GameObject tree1Prefab;
	static GameObject tree2Prefab;
	static GameObject flagPrefab;
	public static GameObject goalPrefab;


	static WorldObject(){
		rockPrefab = Resources.Load("rock") as GameObject;
		tree1Prefab = Resources.Load("tree1") as GameObject;
		tree2Prefab = Resources.Load("tree2") as GameObject;
		flagPrefab = Resources.Load("flag") as GameObject;
		goalPrefab = Resources.Load("goal") as GameObject;

		// Instantiate objects pools
		rocksPool = new GameObject[1000];
		tree1Pool = new GameObject[4000];
		tree2Pool = new GameObject[4000];

		for (int i = 0 ; i < rocksPool.Length ; ++i) {
			rocksPool[i] = GameObject.Instantiate(rockPrefab);
			rocksPool[i].SetActive(false);
			rocksPool[i].transform.position = new Vector3(-999, -999, -999);
		}
		for (int i = 0 ; i < tree1Pool.Length ; ++i) {
			tree1Pool[i] = GameObject.Instantiate(tree1Prefab);
			tree1Pool[i].SetActive(false);
			tree1Pool[i].transform.position = new Vector3(-999, -999, -999);
		}
		for (int i = 0 ; i < tree2Pool.Length ; ++i) {
			tree2Pool[i] = GameObject.Instantiate(tree2Prefab);
			tree2Pool[i].SetActive(false);
			tree2Pool[i].transform.position = new Vector3(-999, -999, -999);
		}
	}


	public void ApplyColorToFlagArros(GameObject arrowsObj)
	{
		SpriteRenderer[] sprites = arrowsObj.GetComponentsInChildren<SpriteRenderer>();
		Color flagColor = type == -2 ? new Color(0.9f, 0.3f, 0.3f) : new Color(0.3f, 0.3f, 0.9f);
		foreach (SpriteRenderer sprite in sprites){
			sprite.material.color = flagColor;
		}
		Transform transform = arrowsObj.transform.Find("quad");
		if (transform != null) {
			GameObject collisionPanel = transform.gameObject;
			MeshRenderer quadRenderer = collisionPanel.GetComponent<MeshRenderer> ();
			quadRenderer.material.color = new Color (flagColor.r, flagColor.g, flagColor.b, 0);
		}
		transform = arrowsObj.transform.Find("signaller");
		if (transform != null) {
			GameObject signaller = transform.gameObject;
			MeshRenderer quadRenderer = signaller.GetComponent<MeshRenderer> ();
			Color signallerColor = type == -2 ? Color.red : Color.blue;
			signallerColor.a = 0.025f;
			quadRenderer.material.color = signallerColor;
		}
		transform = arrowsObj.transform.Find("model");
		if (transform != null) {
			MeshRenderer[] renderers = transform.gameObject.GetComponentsInChildren<MeshRenderer>();
			foreach (MeshRenderer renderer in renderers) {
				renderer.material.color = type == -2 ? Color.red : Color.blue;
			}
		}
	}
	

	public WorldObject(int type, FixedFloat x, FixedFloat y, bool isRight) {
		this.type = type;
		this.y = y;
		this.x1 = x -1.1f;
		this.x2 = x +1.1f;
		this.isRight = isRight;

		float yPos;
		if (type < 0){
			// Flag
			view = GameObject.Instantiate(flagPrefab);
			view.transform.localEulerAngles = new Vector3(10, type == -2 ? 180 : 0, 0);
			view.transform.localScale = new Vector3(0.9f, 0.9f, 0.9f);

			ApplyColorToFlagArros(view);

			yPos = -0.1f;
		}else {

			// Rocks & Trees
			if (type == 0) {
				view = rocksPool[rockPoolId++];
				if (rockPoolId >= rocksPool.Length) rockPoolId = 0;
				this.x1 = x -1.4f;
				this.x2 = x +1.4f;
			}else if (type % 2 == 0){
				view = tree1Pool[tree1PoolId++];
				if (tree1PoolId >= tree1Pool.Length) tree1PoolId = 0;
			}else {
				view = tree2Pool[tree2PoolId++];
				if (tree2PoolId >= tree2Pool.Length) tree2PoolId = 0;
			}
			view.SetActive(true);
			view.transform.localEulerAngles = new Vector3(310 + UnityEngine.Random.Range(-8, 8), UnityEngine.Random.Range(-5, 5), UnityEngine.Random.Range(0, 360));
			float radius = type == 0 ? UnityEngine.Random.Range(1.0f, 1.3f) : UnityEngine.Random.Range(1.5f, 2.0f);
			float scale = type == 0 ? 1 : UnityEngine.Random.Range(0.5f, 1.0f);
			view.transform.localScale = new Vector3(radius, UnityEngine.Random.Range(1.75f, 2.5f), radius);
			view.transform.localScale *= scale;
			yPos = 0.25f; //-0.25f;
			if (type != 0) {
				view.GetComponent<MeshRenderer>().material.color =
					new Color(
						UnityEngine.Random.Range(0.2f, 0.6f),
						UnityEngine.Random.Range(0.2f, 0.7f),
						UnityEngine.Random.Range(0.2f, 0.6f)
					)
				;
			}
		}
		view.transform.localPosition  = new Vector3((float)x, yPos, (float)y);

	}


	public void OnDestroy(){
		// nothing to do
		view.SetActive(false);
	}

}


public class WorldObjects{



	static void ApplyDemoSetup(){
		maxHorizontalDistance = 40;

		maxDifficultyDistance = 10;
		initialCleanupDistance = 9700;
		finalGoalDistance = 9800;
		minFlagDistance = 20;
		maxFlagDistance = 40;
		randomTrackVariation = 30;
		minTrackYGeneration = 20;
		maxTrackYGeneration = 60;
		minFlagHorizontalDist = 0.1f;
		maxFlagHorizontalDist = 0.55f;
		minYForGeneration = 0.5f;

		maxDistanceBehind = 30;
		minDistanceAhead = 60;
		botsInactivityRange = 50.0f;
		botsInvincibilityRange = 30.0f;
		trackType = 0;
	}


	static void ApplyNormalSetup(){
		maxHorizontalDistance = 20;

		maxDifficultyDistance = 600;
		initialCleanupDistance = 675;
		finalGoalDistance = 700;
		minFlagDistance = 20;
		maxFlagDistance = 40;
		randomTrackVariation = 30;
		minTrackYGeneration = 20;
		maxTrackYGeneration = 60;
		minFlagHorizontalDist = 0.1f;
		maxFlagHorizontalDist = 0.6f;
		minYForGeneration = 0.5f;

		maxDistanceBehind = 10;
		minDistanceAhead = 80;
		botsInactivityRange = 5.0f;
		botsInvincibilityRange = 3.0f;
		trackType = 0;
	}


	static void ApplyCleanTrackSetup(){
		maxHorizontalDistance = 40;
		maxDifficultyDistance = -1;
		initialCleanupDistance = -1;
		finalGoalDistance = 350;
		minFlagDistance = 7;
		maxFlagDistance = 20;
		randomTrackVariation = 5;
		minTrackYGeneration = 2;
		maxTrackYGeneration = 6;
		minFlagHorizontalDist = -0.05f;
		maxFlagHorizontalDist = 0.2f;
		minYForGeneration = 0.5f;

		maxDistanceBehind = 10;
		minDistanceAhead = 80;
		botsInactivityRange = 5.0f;
		botsInvincibilityRange = 3.0f;
		trackType = 0;
	}


	static void ApplySplineTrackSetup(){
		maxHorizontalDistance = 9;

		maxDifficultyDistance = 20;
		initialCleanupDistance = 9700;
		finalGoalDistance = 450;

		minFlagDistance = 10;
		maxFlagDistance = 10;
		randomTrackVariation = 50;
		minTrackYGeneration = 45;
		maxTrackYGeneration = 60;
		minFlagHorizontalDist = -1.0f;
		maxFlagHorizontalDist = -0.95f;
		minYForGeneration = 0.15f;

		maxDistanceBehind = 10;
		minDistanceAhead = 80;
		botsInactivityRange = 5.0f;
		botsInvincibilityRange = 3.0f;
		trackType = 1;
	}


	static int trackType = 0;
	// 
	static SimpleRandomGenerator rnd = null;

	public static FixedFloat botsInactivityRange = 5.0f;
	public static FixedFloat botsInvincibilityRange = 3.0f;

	public static uint collisionFallenTime = 45;
	public static uint frozenTime = 150;

	static FixedFloat maxDistanceBehind = 10;
	static FixedFloat minDistanceAhead = 80;
	// every 50 units, resort the list
	static FixedFloat controlRange = 1.0f;

	static FixedFloat maxHorizontalDistance = 20;
	static FixedFloat maxDifficultyDistance = 600;
	static FixedFloat initialCleanupDistance = 675;
	public static FixedFloat finalGoalDistance = 700;

	static FixedFloat minFlagDistance = 20;
	static FixedFloat maxFlagDistance = 40;
	static FixedFloat randomTrackVariation = 30;
	static FixedFloat minTrackYGeneration = 20;
	static FixedFloat maxTrackYGeneration = 60;
	static FixedFloat minFlagHorizontalDist = 0.1f;
	static FixedFloat maxFlagHorizontalDist = 0.6f;
	static FixedFloat minYForGeneration = 0.5f;

	static List<int> yList = new List<int>(100);
	static Dictionary<int, List<WorldObject>> objectsByY = new Dictionary<int, List<WorldObject>>(100);

	static FixedFloat twoLastTrackX;
	static FixedFloat twoLastTrackY;
	static FixedFloat lastTrackX;
	static FixedFloat lastTrackY;
	static FixedFloat nextTrackX;
	static FixedFloat nextTrackY;
	static bool nextFlagIsRight;
	static FixedFloat nextFlagDistance;


	static List<WorldObject> flags = new List<WorldObject>();

	static GameObject goalObj;


	public static void Reset(){
		rnd = null;
		foreach (List<WorldObject> objects in objectsByY.Values){
			foreach (WorldObject obj in objects) {
				obj.OnDestroy();
			}
		}
		yList = new List<int>(100);
		objectsByY = new Dictionary<int, List<WorldObject>>(100);

		twoLastTrackX = 0;
		twoLastTrackY = 0;
		lastTrackX = 0;
		lastTrackY = 0;
		nextTrackX = 0;
		nextTrackY = 0;
		nextFlagIsRight = false;
		nextFlagDistance = 0;
		if (goalObj != null) {
			goalObj.transform.position = new Vector3(999, 999, 999);
		}
		flags = new List<WorldObject>();
	}


	public static WorldObject GetNextFlagForSkier(SkierModel skierModel){
		WorldObject flag = null;
		int removeCount = 0;
		for (int i = 0 ; i < flags.Count ; ++i) {
			flag = flags[i];
			if (flag.y < skierModel.y) {
				break;
			}else {
				++removeCount;
			}
		}
		if (removeCount > 0) {
			flags.RemoveRange(0, removeCount);
		}
		return flag;
	}



	public static WorldObject GetCollisionObject(FixedFloat x, FixedFloat y){
		List<WorldObject> objects;
		if (objectsByY.TryGetValue((int)y, out objects)){
			foreach (WorldObject obj in objects){
				if (obj.type >= 0){
					if (x > obj.x1 && x < obj.x2){
						return obj;
					}
				}else {
					if (obj.type == -2 && x < obj.x1){
						return obj;
					}else if (obj.type == -1 && x > obj.x2){
						return obj;
					}
				}
			}
		}
		return null;
	}


	public static void HandleCollisionWithWorld(State state, WorldModel world, SkierModel skier){

		if (skier.fallenTimer > 0 || skier.frozenTimer > 0){
			return; // ignore if already collided
		}
		WorldObject obj = GetCollisionObject(skier.x, skier.y);
		if (obj != null){
			if (obj.type >= 0){
				// obstacle
				FixedFloat objWidth = obj.x2 - obj.x1;
				FixedFloat objCenterX = (obj.x1+obj.x2)/2.0;
				FixedFloat deltaX = FixedFloat.Abs(skier.x - objCenterX);
				FixedFloat deltaY = FixedFloat.Abs(skier.y - obj.y);
				if (deltaX < 0.225f*objWidth && deltaY < 0.15f) {
					skier.fallenTimer = collisionFallenTime;
					skier.velX = obj.isRight ? -1.4 : 1.4;
					skier.velY = 0.6f;
					skier.targetVelX = 0;
					skier.targetVelY = 0;
				} else if (deltaX < 0.6f*objWidth && deltaY < 0.6f) {
					if (skier.x < objCenterX) {
						skier.velX -= 0.2f;
					} else {
						skier.velX += 0.2f;
					}
					if (deltaY > 0.2f && skier.y > obj.y) {
						skier.velY *= 0.75f; //+= 0.2f;
					}
					skier.velX *= 0.9f;
					skier.velY *= 0.9f;
				}
			}else {
				// flag
				FixedFloat target = state.Random.NextFloat(obj.x1 + 0.01f, obj.x2 - 0.01f);
				skier.y = obj.y + state.Random.NextFloat(1,1.5f);
				skier.frozenTimer =  (uint)(FixedFloat.Abs(skier.x-target) / maxHorizontalDistance) * frozenTime;
				if (skier.frozenTimer > 2*frozenTime) skier.frozenTimer = 2*frozenTime;
				if (skier.frozenTimer < collisionFallenTime) skier.frozenTimer = collisionFallenTime;
				skier.velX = 0;
				skier.velY = 0;
				skier.targetVelX = 0;
				skier.targetVelY = 0;
				skier.x = target;

				// Animate flag collision panel
				if (!GuiMenus.Instance.IsDemoPlaying()) {
					AnimateFlagOnCollision(obj.view);
				}
			}
		}
	}


	private static void AnimateFlagOnCollision(GameObject flagObj){
		if (flagObj == null) return;
		GameObject collisionPanel = flagObj.transform.Find("quad").gameObject;
		FlagCollisionEffect effect = collisionPanel.GetComponent<FlagCollisionEffect>();
		if (effect != null) {
			effect.enabled = true;
		}
	}



	public static void HandleCollisionWithOtherSkiers(WorldModel world, SkierModel skier){

		if (skier.fallenTimer > 0 || skier.frozenTimer > 0){
			return; // ignore if already collided
		}

		SkierModel otherSkier;

		for (uint skierId = 0 ; skierId < world.skiers.Length ; ++skierId){
			otherSkier = world.skiers[skierId];
		
			if (otherSkier != null && otherSkier != skier && otherSkier.frozenTimer == 0){
				if ((int)skier.y == (int)otherSkier.y){
					FixedFloat deltaX = FixedFloat.Abs(skier.x - otherSkier.x);
					FixedFloat deltaY = FixedFloat.Abs(skier.y - otherSkier.y);
					if (deltaX < 0.15f && deltaY < 0.2f) {
						skier.fallenTimer = collisionFallenTime;
						skier.velX = skier.x < otherSkier.x ? -1.2 : 1.2;
						skier.velY = 0.4f;
						skier.targetVelX = 0;
						skier.targetVelY = 0;
					} else if (deltaX < 0.25f && deltaY < 0.35f) {
						if (skier.x < otherSkier.x) {
							skier.velX -= 0.8f;
						} else {
							skier.velX += 0.8f;
						}
						if (deltaY > 0.1f) {
							if (skier.y < otherSkier.y) {
								skier.velY -= 0.25f;
							} else {
								skier.velY += 0.5f;
							}
						}
					}
				}
			}
		}
	}



	private static FixedVector3 NextTargetFlagForBot(WorldModel world, SkierModel skier){
		// Find next flag
		FixedFloat extraX = 0;
		if (skier == world.skiers[1]) {
			extraX = 0.15f;
		} else if (skier == world.skiers[3]) {
			extraX = 0.2f;
		}
		List<WorldObject> objects;
		bool secondFlag = false;
		bool direct = false;
		FixedVector3 res1 = FixedVector3.Zero;
		for (int y = (int)skier.y - 1; y >= -finalGoalDistance - 10; --y) {
			if (objectsByY.TryGetValue ((int)y, out objects)) {
				foreach (WorldObject obj in objects) {
					if (obj.type < 0) {
						direct = false;
						FixedVector3 res = new FixedVector3(obj.type == -2 ? obj.x2 + extraX : obj.x1 - extraX , obj.y, 0);
						if ((obj.type == -2 && res.X < skier.x) || obj.type == -1 && res.X > skier.x) {
							if (skier == world.skiers [2]) {
								res.X = (res.X + skier.x) * 0.5f;
							}else if (skier == world.skiers[4]) {
								res.X = (res.X + skier.x) * 0.75f;
							}else {
								res.X = skier.x;
								direct = true;
							}
						}
						//res.Y += 0.5f;
						if (secondFlag) {
							return (res + res1) * 0.5;
						}else if (trackType == 0 || !direct) {
							return res;
						} else {
							res1 = res;
							secondFlag = true;
						}
					}
				}
			}
		}
		return new FixedVector3(0, -finalGoalDistance - 10, 0);
	}



	private static void UpdateTargetAngleBasedOnOpponents(WorldModel world, SkierModel skier, FixedFloat targetX, int targetY, ref FixedFloat targetAngle){
		SkierModel otherSkier;

		FixedFloat xProximity = 1.5f;
		FixedFloat howMuchMoveAway = 0.5f;
		if (skier == world.skiers [1])
			howMuchMoveAway = 0.95f;
		else if (skier == world.skiers [4]) {
			xProximity = 3.0f;
			howMuchMoveAway = 0.45f;
		} else if (skier == world.skiers [2]) {
			xProximity = 4.15f;
		}

		for (uint skierId = 0 ; skierId < world.skiers.Length ; ++skierId){
			otherSkier = world.skiers[skierId];

			if (otherSkier != null && otherSkier != skier && otherSkier.frozenTimer == 0){
				if (FixedFloat.Abs(skier.y - otherSkier.y) < 1.5f ){
					if (FixedFloat.Abs(skier.x - otherSkier.x) < xProximity){

						if (skier.x > otherSkier.x) {
							targetAngle -= howMuchMoveAway;
						}else{
							targetAngle += howMuchMoveAway;
						}
						return;
					}
				}
			}
		}
	}




	private static void UpdateTargetAngleBasedOnObstacles(WorldModel world, SkierModel skier, ref FixedVector3 target, ref FixedFloat targetAngle){
		List<WorldObject> objects;
		FixedFloat objX = 0;
		FixedFloat deltaX;
		FixedFloat deltaY;
		FixedFloat extraAngle;
		FixedFloat extraX = 1.5f; //StateManager.state.Random.NextFloat(1.5f, 3.0f);
		FixedFloat detectionLimit = 5.0f;
		if (skier == world.skiers[2]) {
			detectionLimit = 3.5f;
			extraX = 2.5f;
		} else if (skier == world.skiers[4]) {
			detectionLimit = 6.0f;
			extraX = 4.0f;
		} else if (skier == world.skiers[3]) {
			detectionLimit = 2.5f;
		}
		bool right;
		FixedFloat closestDeltaX;
		WorldObject closestObject;
		//bool right = targetAngle < 0;
		for (int y = (int)skier.y; y >= (int)target.Y-2; --y) {
			if (objectsByY.TryGetValue(y, out objects)) {
				closestObject = null;
				closestDeltaX = 9999;
				foreach (WorldObject obj in objects) {
					if (obj.type >= 0) {
						objX = (obj.x1 + obj.x2) * 0.5f;
						deltaX = skier.x - objX; //(right ? obj.x2 : obj.x1);
						if (FixedFloat.Abs(deltaX) < FixedFloat.Abs(closestDeltaX)) {
							closestDeltaX = deltaX;
							closestObject = obj;
						}
					}
				}
				if (closestObject != null) {
					deltaX = closestDeltaX;
					deltaY = skier.y - closestObject.y;
					if (FixedFloat.Abs(deltaX) > deltaY + 2) continue;
					if (deltaY <= 0)
						deltaY = 0.5f; //deltaX < 1 ? 0.01f : 1.0f;
					extraAngle = 0;
					if (deltaX != 0) {
						extraAngle = FixedFloat.HalfPI - FixedFloat.Atan2(deltaY, deltaX);
					}
					if (FixedFloat.Abs(extraAngle - targetAngle) < detectionLimit / deltaY) {
						objX = (closestObject.x1 + closestObject.x2) * 0.5f;
						if (deltaY > 2) {
							right = objX < target.X; // objX < skier.x; //extraAngle > targetAngle;
							deltaY -= 0.5f;
						} else {
							right = objX < skier.x + 2*skier.velX;
						}
						deltaX = skier.x - (right ? closestObject.x2 + extraX : closestObject.x1 - extraX);
						extraAngle = FixedFloat.HalfPI - FixedFloat.Atan2(deltaY, deltaX);
						if ((right && extraAngle < targetAngle) || (!right && extraAngle > targetAngle)) {
							targetAngle = extraAngle;
							target.Y = closestObject.y;
							return;
						}
					}
				}
			}
		}
	}



	public static FixedFloat GetTargetAxisForBot(State state, WorldModel world, SkierModel skier){

		// randomization based on player position
		FixedFloat deltaYToPlayer = world.skiers [0].y - skier.y;

		if (skier.fallenTimer > 0 || skier.frozenTimer > 0 || (deltaYToPlayer > 1 && state.Random.NextFloat (0, deltaYToPlayer * 0.05f) > 3.0f)) {
			return FixedFloat.Zero; // ignore if on the floor
		}

		FixedFloat targetAxis;
		FixedFloat originalAngle = FixedFloat.HalfPI - FixedFloat.Atan2 (-skier.velY, skier.velX);
		FixedVector3 target = NextTargetFlagForBot(world, skier);
			
		if (skier.y < world.skiers [0].y + WorldObjects.botsInactivityRange) {

			FixedFloat deltaX = skier.x - target.X;
			FixedFloat deltaY = skier.y - target.Y;
			FixedFloat targetAngle = 0;

			//		if (skier.y < -2.0f && skier.velY > -0.25f && FixedFloat.Abs(skier.velX) < 0.4f) {
			//			return -deltaX;
			//		}

				
			if (deltaX != 0) {
				if (!(skier == world.skiers[2] && deltaY > 6.0f && FixedFloat.Abs(deltaX) < deltaY * 0.25f)) {
					targetAngle = FixedFloat.HalfPI - FixedFloat.Atan2 (deltaY, deltaX);
				}
				if (skier == world.skiers[1] && deltaY > 6.0f) {
					targetAngle *= 0.5f;
				}
			}

			if (deltaY > 3.0f) {
				if (skier == world.skiers[1] || skier == world.skiers[4]) {
					targetAngle += deltaX * 0.05f;
				} else if (skier == world.skiers[2] && deltaY > 12.0f) {
					targetAngle /= FixedFloat.Sqrt(deltaY);
				}
			}


			//UpdateTargetAngleBasedOnOpponents (world, skier, target.X, (int)target.Y, ref targetAngle);
			UpdateTargetAngleBasedOnObstacles(world, skier, ref target, ref targetAngle);


			targetAxis = (-targetAngle - originalAngle);

			deltaY = skier.y - target.Y;
			if (deltaY > 2.5) {
				if (skier == world.skiers[1])
					targetAxis *= 0.105f;
				else if (skier == world.skiers[3])
					targetAxis /= FixedFloat.Sqrt(deltaY);
				else
					targetAxis *= 0.12f;
			} else {
				if (skier.velY > -0.1f){
					targetAxis *= 0.275f;
				}else{
					targetAxis *= 0.190f;
				}
			}
		} else {
			targetAxis = -originalAngle;
			skier.x = FixedFloat.Lerp(skier.x, target.X, 0.01f);
		}

			
		return targetAxis;
	}


	static FixedFloat GetNextFlagY(){
		FixedFloat nextFlagY = nextFlagDistance - rnd.NextFloat(minFlagDistance, maxFlagDistance);
		if (nextFlagY < -finalGoalDistance + maxFlagDistance && nextFlagY > -finalGoalDistance) {
			nextFlagY = -finalGoalDistance;
		}
		return nextFlagY;
	}



	static FixedFloat GetDifficultySetting(FixedFloat nextY, bool generation = false){
		if (maxDifficultyDistance == -1) return FixedFloat.Zero;
		if (nextY > -maxDifficultyDistance) {
			return -nextY / maxDifficultyDistance;
		} else if (nextY < -initialCleanupDistance && nextY > -finalGoalDistance) {
			return (-nextY - initialCleanupDistance) / (finalGoalDistance - initialCleanupDistance);
		} else if (nextY < -finalGoalDistance) {
			return FixedFloat.Zero;
		}
		return FixedFloat.One;
	}

	public static void UpdateTrack(State state, WorldModel world, FixedFloat minY, FixedFloat maxY) {

		if (rnd == null){
			uint seed = state.Random.NextUnsignedInt();
			rnd = new SimpleRandomGenerator(seed);
			if (GuiMenus.Instance.demoStateManager == null || state != GuiMenus.Instance.demoStateManager.state) {
				switch (state.Random.NextInt(0, 3)) {
					case 0:{
						ApplyCleanTrackSetup();
						break;
					}
					case 1:{
						ApplySplineTrackSetup();
						break;
					}
					default:{
						ApplyNormalSetup();
						break;
					}
				}
			} else {
				ApplyDemoSetup();
			}
			nextFlagIsRight = rnd.NextUnsignedInt() % 2 == 0;
			nextFlagDistance = GetNextFlagY();
		}

		if (yList.Count > 0) {

			bool removedSome;
			int index;
			// remove old objects
			if (yList.Count > 0){
				FixedFloat minKnownY = yList[0];
				if (minY < minKnownY - controlRange) {
					removedSome = false;
					for (index = 0 ; index < yList.Count && yList[index] > minY + maxDistanceBehind ; ++index){
						List<WorldObject> objects;
						if (objectsByY.TryGetValue(yList[index], out objects)){
							foreach (WorldObject obj in objects) {
								obj.OnDestroy();
							}
						}
						objectsByY.Remove(yList[index]);
						removedSome = true;
					}
					if (removedSome) {
						yList.RemoveRange(0, index+1);
					}
				}
			}
		}

		// create more track
		FixedFloat maxKnownY = yList.Count == 0 ? -5 : yList[yList.Count-1];
		FixedFloat distanceAhead;
//		if (StateManager.state.Keyframe > 180){
			distanceAhead = minDistanceAhead - controlRange;
//		}else {
//			distanceAhead = (FixedFloat.Create(StateManager.state.Keyframe) / 180.0f) * (minDistanceAhead - controlRange);
//		}
		FixedFloat nextTargetY = maxY - distanceAhead;

		FixedFloat nextY;
		int latestIntY = (int)maxKnownY;
		bool nextObjectIsFlag;
		FixedFloat difficultySetting = GetDifficultySetting(maxKnownY);
		FixedFloat limitForObjects = minYForGeneration + (1-difficultySetting) * 3.0f;
		for (nextY = maxKnownY - 0.0001f ; nextY > nextTargetY ; ){
			nextY -= rnd.NextFloat(0.0001f, limitForObjects);
			nextObjectIsFlag = nextY < nextFlagDistance && nextFlagDistance >= -finalGoalDistance;
			while (nextY < nextTrackY){
				twoLastTrackX = lastTrackX;
				twoLastTrackY = lastTrackY;
				lastTrackY = nextY;
				lastTrackX = nextTrackX;
				if (trackType == 1) {
					nextTrackX = nextTrackX + (rnd.NextFloat (0.75, 1.0) * randomTrackVariation) * (-1 + rnd.NextInt(0, 1)*2);
				} else {
					nextTrackX = nextTrackX + rnd.NextFloat (-randomTrackVariation, randomTrackVariation);
				}
				nextTrackY = nextY - rnd.NextFloat(minTrackYGeneration, maxTrackYGeneration);
			}

			int nextIntY = (int)nextY;
			if (nextIntY != latestIntY){
				yList.Add(nextIntY);
				latestIntY = nextIntY;
			}
			List<WorldObject> newObjects;
			if (!objectsByY.TryGetValue(nextIntY, out newObjects)) {
				newObjects = new List<WorldObject>();
				objectsByY.Add(nextIntY,newObjects);
			}
			FixedFloat centerX;
			FixedFloat randomX;

			centerX = GetCenterXForY(nextY);
			if (nextObjectIsFlag){
				randomX = rnd.NextFloat(maxHorizontalDistance* minFlagHorizontalDist, maxHorizontalDistance * maxFlagHorizontalDist);
				randomX = centerX + (nextFlagIsRight ? randomX : -randomX);
				WorldObject flagObj = new WorldObject(nextFlagIsRight ? -2 : -1, randomX, nextY, nextFlagIsRight);
				newObjects.Add(flagObj);
				flags.Add(flagObj);
				nextFlagIsRight = !nextFlagIsRight;
				if (nextFlagDistance == -finalGoalDistance) {
					// it's the goal, add an extra flag and spawn goal view
					randomX = nextFlagIsRight ? randomX - 8 : randomX + 8;
					flagObj = new WorldObject(nextFlagIsRight ? -2 : -1, randomX, nextY, nextFlagIsRight);
					newObjects.Add(flagObj);
					flags.Add(flagObj);
					if (goalObj == null) {
						goalObj = GameObject.Instantiate(WorldObject.goalPrefab);
					}
					goalObj.transform.position = new Vector3((float)(nextFlagIsRight ? randomX + 4 : randomX - 4), 0, (float)-finalGoalDistance);
				}
				nextFlagDistance = GetNextFlagY();
				flags.Add(flagObj);
			}else {
				randomX = GetRandomXAroundCenter(centerX, nextY);
				newObjects.Add(new WorldObject(rnd.NextInt(0, 4), randomX, nextY, randomX > centerX));
			}


		}

	}


	public static FixedFloat GetAverageXForY(int y){
		List<WorldObject> objects;
		if (objectsByY.TryGetValue(y, out objects)) {
			FixedFloat avg = 0;
			foreach (WorldObject obj in objects) {
				avg += (obj.x1 + obj.x2) * 0.5f;
			}
			avg /= objects.Count;
			return avg;
		}
		return -1;
	}

	
	static FixedFloat GetCenterXForY(FixedFloat y){
//		FixedFloat t = (y-lastY) / (newY - lastY);
//		return lastX + t * (newX - lastX);

		//lastTrackY, nextTrackY, lastTrackX, nextTrackX

		if (trackType == 1) {
			FixedFloat t = (y - lastTrackY) / (nextTrackY - lastTrackY);
			FixedFloat oneMinusT = FixedFloat.One - t;
			return oneMinusT * oneMinusT * lastTrackX +
			2 * oneMinusT * t * twoLastTrackX +
			t * t * nextTrackX;
		} else {
			FixedFloat t = (y-lastTrackY) / (nextTrackY - lastTrackY);
			return lastTrackX + t * (nextTrackX - lastTrackX);
		}
	}

	static FixedFloat GetRandomXAroundCenter(FixedFloat center, FixedFloat nextY) {
		FixedFloat randomT = rnd.NextFloat(0, 1);

		FixedFloat difficultySetting = GetDifficultySetting(nextY, true);
		if (maxDifficultyDistance == -1 || trackType == 1) {
			if (trackType == 1) {
				randomT = randomT * 0.94f;
			}
			randomT = randomT * randomT * randomT * randomT;
		} else {
			if (difficultySetting < 0.5) {
				randomT *= randomT;
			}
			if (rnd.NextFloat (0, 1) < difficultySetting + 0.15f) {
				randomT *= randomT;
			}
		}

		randomT = 1.05f - randomT;
		if (rnd.NextInt(0,1) == 0) {
			randomT *= -1;
		}
		if (trackType == 1) {
			return center + (-1 + (randomT * 2) * maxHorizontalDistance);
		}
		return center + (randomT * (maxHorizontalDistance*(1+(1-difficultySetting)*0.5f)));
	}

}

